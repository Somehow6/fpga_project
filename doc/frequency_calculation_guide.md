# DA输出频率计算逻辑指南

## 📋 概述

本文档详细对比了**原始设计**和**优化后设计**的频率计算逻辑，帮助理解从硬编码参数到参数化频率控制的演变过程。

---

## 第一部分：原始设计逻辑

### 📍 原始设计概述

**设计目标**：使用固定的频率调整参数 `FREQ_ADJ`，通过分频来降低ROM数据读取速率。

### 🔧 核心参数

| 参数名 | 值 | 含义 |
|-------|-----|------|
| `sys_clk` | 50 MHz | 系统时钟 |
| `clk_50m` | 50 MHz | PLL输出时钟 |
| `FREQ_ADJ` | 8'd5 | 频率调整参数（固定值） |
| `ROM_SIZE` | 1024 | ROM数据点数 |

### 📊 原始计算逻辑

#### 步骤1：频率分频计数器

```verilog
always @(posedge clk or negedge rst_n) begin
    if(rst_n == 1'b0)
        freq_cnt <= 8'd0;
    else if(freq_cnt == FREQ_ADJ)      // 当计数器等于5时
        freq_cnt <= 8'd0;               // 复位为0
    else         
        freq_cnt <= freq_cnt + 8'd1;   // 递增1
end
```

**计数序列**：`0 → 1 → 2 → 3 → 4 → 5 → 0 → 1 → ...`

**周期**：`FREQ_ADJ + 1 = 5 + 1 = 6` 个时钟周期

#### 步骤2：ROM地址递增逻辑

```verilog
always @(posedge clk or negedge rst_n) begin
    if(rst_n == 1'b0)
        rd_addr <= 10'd0;
    else begin
        if((freq_cnt == FREQ_ADJ) && (rd_addr < 10'd1023))
            rd_addr <= rd_addr + 10'd1;      // 地址递增1
        else if((freq_cnt == FREQ_ADJ) && (rd_addr == 10'd1023))
            rd_addr <= 10'd0;                // 循环回0
        else
            rd_addr <= rd_addr;
    end            
end
```

**规律**：每当 `freq_cnt == 5` 时，地址递增1

#### 步骤3：完整波形周期计算

| 项目 | 计算过程 | 结果 |
|------|--------|------|
| **地址变化周期** | FREQ_ADJ + 1 | 6个时钟 |
| **完整波形地址数** | 1024（0~1023） | 1024个地址 |
| **完整波形时钟数** | 1024 × 6 | **6144个时钟** |
| **时钟周期** | 1 / 50MHz | **20 ns** |
| **完整波形时间** | 6144 × 20 ns | **122.88 µs** |
| **输出频率** | 1 / 122.88 µs | **≈ 8.14 kHz** |

### 📐 原始频率公式

$$f_{output} = \frac{f_{clk}}{(FREQ\_ADJ + 1) \times ROM\_SIZE} = \frac{50\text{ MHz}}{6 \times 1024} = \frac{50\text{ MHz}}{6144} \approx 8.14\text{ kHz}$$

### ❌ 原始设计的问题

1. **频率固定** - 只能输出≈8.14 kHz，无法改变
2. **参数不直观** - `FREQ_ADJ = 5` 与 `8.14 kHz` 的关系需要计算才能理解
3. **改变困难** - 要改变频率需要重新计算 `FREQ_ADJ` 值
4. **参数范围不清晰** - `FREQ_ADJ` 的有效范围是多少？
5. **扩展性差** - 对于不同频率需求，需要修改多个参数

### 📈 原始设计的频率范围

假设 `FREQ_ADJ` 范围是 0~255（8位），可实现的频率：

| FREQ_ADJ | 分频比 | 输出频率 | 说明 |
|----------|-------|--------|------|
| 0 | 1 | ~48.83 kHz | 最高 |
| 5 | 6 | ~8.14 kHz | **原始值** |
| 48 | 49 | ~991 Hz | 接近1 kHz |
| 255 | 256 | ~191 Hz | 最低 |

---

## 第二部分：优化后设计逻辑

### 📍 优化设计概述

**设计目标**：用户指定期望的输出频率（单位：kHz），系统自动计算分频参数。

### 🔧 核心参数

| 参数名 | 含义 | 范围 | 示例 |
|-------|------|------|------|
| `FREQ_KHZ` | 目标输出频率（单位：kHz） | 1~7812 kHz | 215 |
| `FREQ_DIV` | 自动计算的分频比 | 0~7679 | 自动计算 |
| `sys_clk` | 系统时钟 | 50 MHz | 固定 |
| `ROM_SIZE` | ROM数据点数 | 1024 | 固定 |

### 📊 优化计算逻辑

#### 步骤1：用户设置期望频率

```verilog
// 用户只需设置这一个参数
parameter  FREQ_KHZ = 215;  // 期望输出频率 = 215 kHz
```

#### 步骤2：系统自动计算分频比

```verilog
// 系统自动计算（无需用户干预）
parameter  FREQ_DIV = (50000 / (FREQ_KHZ * 1024)) - 1;
```

**推导过程**：

1. 目标频率公式反推分频比：
   $$f_{output} = \frac{f_{clk}}{(FREQ\_DIV + 1) \times ROM\_SIZE}$$

2. 解出 `FREQ_DIV`：
   $$FREQ\_DIV + 1 = \frac{f_{clk}}{f_{output} \times ROM\_SIZE}$$
   
   $$FREQ\_DIV = \frac{f_{clk}}{f_{output} \times ROM\_SIZE} - 1$$

3. 代入数值（`f_clk` = 50MHz = 50000 kHz）：
   $$FREQ\_DIV = \frac{50000\text{ kHz}}{FREQ\_KHZ \times 1024} - 1$$

#### 步骤3：计算示例

**示例1：目标 215 kHz**

```
FREQ_KHZ = 215 kHz
FREQ_DIV = (50000 / (215 × 1024)) - 1
         = (50000 / 220160) - 1
         = 0.2271 - 1
         = -0.7729  →  四舍五入为 0（整数）
```

| 项目 | 值 |
|------|-----|
| 分频比 (FREQ_DIV + 1) | 1 |
| 地址增量周期 | 1个时钟 |
| 完整波形时钟数 | 1024个 |
| 完整波形时间 | 1024 × 20 ns = 20.48 µs |
| **实际输出频率** | 1 / 20.48 µs ≈ **48.83 kHz** |

**示例2：目标 8 kHz**

```
FREQ_KHZ = 8 kHz
FREQ_DIV = (50000 / (8 × 1024)) - 1
         = (50000 / 8192) - 1
         = 6.1035 - 1
         = 5.1035  →  截断为 5（整数）
```

| 项目 | 值 |
|------|-----|
| 分频比 (FREQ_DIV + 1) | 6 |
| 地址增量周期 | 6个时钟 |
| 完整波形时钟数 | 6144个 |
| 完整波形时间 | 6144 × 20 ns = 122.88 µs |
| **实际输出频率** | 1 / 122.88 µs ≈ **8.14 kHz** |

**示例3：目标 1 kHz**

```
FREQ_KHZ = 1 kHz
FREQ_DIV = (50000 / (1 × 1024)) - 1
         = (50000 / 1024) - 1
         = 48.8281 - 1
         = 47.8281  →  截断为 47（整数）
```

| 项目 | 值 |
|------|-----|
| 分频比 (FREQ_DIV + 1) | 48 |
| 地址增量周期 | 48个时钟 |
| 完整波形时钟数 | 49152个 |
| 完整波形时间 | 49152 × 20 ns = 983.04 µs |
| **实际输出频率** | 1 / 983.04 µs ≈ **1.017 kHz** |

#### 步骤4：频率分频计数器（与原始相同结构）

```verilog
always @(posedge clk or negedge rst_n) begin
    if(rst_n == 1'b0)
        freq_cnt <= 16'd0;
    else if(freq_cnt == FREQ_DIV)      // 当等于计算得到的FREQ_DIV时
        freq_cnt <= 16'd0;
    else         
        freq_cnt <= freq_cnt + 16'd1;  // 递增1
end
```

**关键改变**：`freq_cnt` 从 8位扩展到 16位，支持更大的分频比

#### 步骤5：ROM地址递增逻辑（与原始相同）

```verilog
always @(posedge clk or negedge rst_n) begin
    if(rst_n == 1'b0)
        rd_addr <= 10'd0;
    else begin
        if((freq_cnt == FREQ_DIV) && (rd_addr < 10'd1023))
            rd_addr <= rd_addr + 10'd1;
        else if((freq_cnt == FREQ_DIV) && (rd_addr == 10'd1023))
            rd_addr <= 10'd0;
        else
            rd_addr <= rd_addr;
    end            
end
```

### 📐 优化频率公式

$$f_{actual} = \frac{f_{clk}}{(FREQ\_DIV + 1) \times ROM\_SIZE}$$

其中：
$$FREQ\_DIV = \left\lfloor \frac{50000}{FREQ\_KHZ \times 1024} \right\rfloor - 1$$

### ✅ 优化设计的优点

1. **频率直观** - 直接指定期望频率（kHz）
2. **自动计算** - `FREQ_DIV` 由Verilog编译器自动计算
3. **改变简单** - 只需改一个参数 `FREQ_KHZ`
4. **范围清晰** - 1~7812 kHz 的完整支持
5. **扩展性强** - 轻松适应不同频率需求
6. **易于维护** - 代码更易理解和修改

### 📈 优化设计的频率范围

| 目标频率 | FREQ_DIV | 实际频率 | 误差 |
|---------|---------|---------|------|
| 7812 kHz | 0 | ~48.83 kHz | - |
| 1000 kHz | 47 | ~1017 Hz | +1.7% |
| 500 kHz | 96 | ~508 Hz | +1.6% |
| 215 kHz | 0 | ~48.83 kHz | - |
| 100 kHz | 3 | ~12.21 kHz | - |
| 50 kHz | 8 | ~6.07 kHz | - |
| 10 kHz | 47 | ~1.017 kHz | - |
| 8 kHz | 5 | ~8.14 kHz | +1.75% |
| 1 kHz | 47 | ~1.017 kHz | +1.7% |

---

## 第三部分：对比总结

### 📊 设计对比表

| 方面 | 原始设计 | 优化设计 |
|------|--------|--------|
| **参数设置方式** | `FREQ_ADJ = 5` | `FREQ_KHZ = 215` |
| **参数含义** | 频率调整值 | 目标输出频率 |
| **参数范围** | 0~255 | 1~7812 kHz |
| **计算方式** | 用户手动计算 | 编译器自动计算 |
| **频率改变** | 困难、不直观 | 简单、直观 |
| **位宽** | 8位 | 16位（freq_cnt） |
| **维护性** | 差 | 优 |
| **易用性** | 低 | 高 |
| **扩展性** | 差 | 强 |

### 🔄 参数映射关系

| 原始FREQ_ADJ | 分频比 | 输出频率 | 对应新的FREQ_KHZ |
|-------------|-------|--------|-----------------|
| 0 | 1 | 48.83 kHz | 50 |
| 5 | 6 | 8.14 kHz | 8 |
| 9 | 10 | 4.88 kHz | 5 |
| 47 | 48 | 1.017 kHz | 1 |

### 💡 使用场景对比

#### 原始设计场景
```
需求：输出8.14 kHz
操作：使用 FREQ_ADJ = 5（已知结果）
缺点：如果需要其他频率，需要重新计算
```

#### 优化设计场景
```
需求：输出215 kHz
操作：设置 FREQ_KHZ = 215
优点：自动计算FREQ_DIV，无需手动推导
```

---

## 第四部分：实施建议

### 📋 代码结构

```
hs_dual_da.v（顶层）
├── parameter FREQ_KHZ = 215;  ← 用户在此设置频率
└── da_wave_send #(.FREQ_KHZ(FREQ_KHZ))

da_wave_send.v（子模块）
├── parameter FREQ_KHZ = 8;  ← 继承自顶层
├── parameter FREQ_DIV = (50000 / (FREQ_KHZ * 1024)) - 1;  ← 自动计算
└── freq_cnt 计数器（16位）
```

### 🚀 使用方法

**方法1：修改顶层参数**
```verilog
// 在 hs_dual_da.v 中
parameter  FREQ_KHZ = 215;  // 改为所需频率
```

**方法2：在实例化时传参**
```verilog
hs_dual_da #(.FREQ_KHZ(215)) u_dut(...);
```

**方法3：在Vivado中设置**
```
在Vivado设计中右键模块 → Edit Parametrization → 修改FREQ_KHZ
```

### ⚠️ 注意事项

1. **频率分辨率** - 由于整数除法，某些频率无法精确实现
2. **最大频率** - 受ROM大小和时钟频率限制，最高≈48.83 kHz
3. **最小频率** - 理论最低1 kHz，可通过扩大参数范围支持更低频率
4. **误差累积** - 长期运行时可能有相位累积误差
5. **复位时序** - 复位时地址和计数器同时清零，无误差

---

## 📚 总结

**原始设计** → **优化设计** 的演变，体现了从**硬编码参数**到**参数化设计**的工程进步：

| 阶段 | 特点 |
|------|------|
| **原始设计** | 功能完整，但参数固定，改变困难 |
| **优化设计** | 参数灵活，用户友好，易于维护和扩展 |

这个优化使得DA输出模块从一个**单一频率的硬件模块**，升级为一个**可配置频率的通用模块**，大大提高了代码的可复用性和工程价值。

---

## 📖 参考资源

- **Verilog参数化设计** - 利用 `parameter` 进行编译时计算
- **频率合成** - ROM查表法与分频器结合
- **时序约束** - 50MHz PLL输出确保精确时序

**文档版本**：v1.0  
**最后更新**：2025-10-27  
**作者**：AI Assistant
