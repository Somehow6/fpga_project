# 相位调试数据包分析

**日期**: 2025/11/08

---

## 📊 数据包字段对比

### 方案A: 纯相位数据（当前）
```
连续发送: phase_diff_8bit (8-bit, 0-255 → 0-360度)
数据率: 4 MB/s
数据量: 1 字节/采样点
```

**优点**:
- ✅ 简单直接
- ✅ 高采样率（可以看到相位快速变化）
- ✅ 数据量小，易于处理

**缺点**:
- ❌ 只能看到相位结果
- ❌ 无法诊断问题（为什么相位是0-2？）
- ❌ 不知道零交叉是否工作
- ❌ 不知道ADC信号质量

---

### 方案B: 完整调试数据包
```
数据包结构（每包12字节）:
┌────────────────────────────────────────────────────────┐
│ Header   │ Phase │ Midpoint │ Min  │ Max  │ Count │CRC│
│ (2B)     │ (1B)  │ (2B)     │ (2B) │ (2B) │ (2B)  │(1B)│
├──────────┴───────┴──────────┴──────┴──────┴───────┴───┤
│ 0xAA 0x55│ 0-255 │ 12-bit   │12-bit│12-bit│16-bit │sum│
└────────────────────────────────────────────────────────┘
   帧头      相位    动态零点   ADC最小 ADC最大 零交叉计数 校验
```

**字段说明**:
1. **Header (2B)**: 帧头标识 [0xAA, 0x55]
2. **Phase (1B)**: phase_diff_8bit (0-255 → 0-360度)
3. **Midpoint (2B)**: adc_midpoint (12-bit, 高8位+低4位)
4. **Min (2B)**: adc_min (12-bit)
5. **Max (2B)**: adc_max (12-bit)
6. **Count (2B)**: zero_cross_count (16-bit)
7. **CRC (1B)**: 简单校验和

---

## 🔍 每个字段能告诉你什么

### 1️⃣ Phase (相位) - 1字节
```
数值: 0-255 (映射到0-360度)
```

**能看到**:
- ✅ DA和ADC的相位关系
- ✅ 相位是否稳定（抖动情况）
- ✅ 相位随时间的变化趋势

**分析示例**:
```python
# 连续读取相位数据
phases = [120, 121, 120, 119, 120, ...]  # 稳定在120度附近 ✓
phases = [0, 1, 2, 0, 1, 0, ...]        # 异常：只在0-2徘徊 ❌
phases = [120, 200, 50, 180, ...]       # 异常：跳变剧烈 ❌
```

---

### 2️⃣ Midpoint (动态零点) - 2字节
```
数值: 0-4095 (12-bit ADC值)
理想值: 2048 (0V参考点)
```

**能看到**:
- ✅ ADC信号的DC偏置量
- ✅ 零点校准是否完成（前64个采样点后应稳定）
- ✅ 信号漂移情况（温度/老化影响）

**诊断示例**:
```python
# Case 1: 无偏置
midpoint = 2048  → ADC信号完美居中 ✓

# Case 2: 有偏置
midpoint = 2150  → ADC信号偏高102 (约0.25V)
                  → 动态校准自动修正 ✓

# Case 3: 严重偏置
midpoint = 3000  → ADC信号严重偏高952 (约2.3V)
                  → 可能硬件问题，需检查 ⚠️

# Case 4: 零点不稳定
midpoint = [2100, 2200, 2050, 2300, ...]
         → 信号噪声大或校准未完成 ❌
```

**问题定位**:
- 如果相位异常 + midpoint偏离2048严重
  → 说明问题出在ADC信号偏置，V1检测器无法处理
  → V2动态校准可以解决

---

### 3️⃣ Min & Max (ADC范围) - 4字节
```
数值: 0-4095 (12-bit ADC值)
```

**能看到**:
- ✅ ADC信号的摆幅
- ✅ 信号是否饱和（达到0或4095）
- ✅ 信号质量（最小/最大差值）

**分析示例**:
```python
# Case 1: 正常信号
min = 1800, max = 2300
amplitude = (2300 - 1800) / 2 = 250  → 约0.6V摆幅
center = (2300 + 1800) / 2 = 2050    → 中心点接近2048 ✓

# Case 2: 信号太弱
min = 2000, max = 2100
amplitude = 50  → 仅0.12V摆幅，信号太小 ⚠️
                → 可能压电振子耦合不好

# Case 3: 信号饱和
min = 0, max = 4095
                → ADC满量程，信号过强或有问题 ❌

# Case 4: 无信号
min = max = 2048
                → ADC无输入或DA未输出 ❌

# Case 5: 信号有严重偏置
min = 2500, max = 3500
center = 3000    → 严重偏离2048 (约+2.3V偏置) ⚠️
```

**问题定位**:
- 相位异常 + amplitude很小
  → DA输出可能有问题，或ADC采集不到信号
- 相位异常 + min=max
  → 完全无信号变化，零交叉不可能触发

---

### 4️⃣ Zero-Cross Count (零交叉计数) - 2字节
```
数值: 0-65535 (16-bit计数器，循环)
增长率: 应该≈DA输出频率
```

**能看到**:
- ✅ 零交叉检测是否工作
- ✅ 实际信号频率（通过计数增长率）
- ✅ 零交叉检测是否稳定（是否漏检/误检）

**分析示例**:
```python
# Case 1: 正常工作（215kHz DA输出）
t0: count = 1000
t1 (1秒后): count = 216000
频率 = (216000 - 1000) / 1秒 = 215 kHz ✓

# Case 2: 零交叉检测失败
t0: count = 100
t1 (1秒后): count = 100
频率 = 0 Hz  → 零交叉完全未触发 ❌
            → 检查midpoint, min, max找原因

# Case 3: 频率异常
t0: count = 1000
t1 (1秒后): count = 11000
频率 = 10 kHz  → 远低于预期215kHz ⚠️
               → 可能只有部分零交叉被检测到

# Case 4: 频率过高（误检）
t0: count = 1000
t1 (1秒后): count = 2000000
频率 = 2 MHz  → 远高于预期，可能噪声触发 ❌
```

**问题定位**:
- 相位异常 + count不增长
  → 零交叉检测失败，根本原因
- 相位异常 + count增长很慢
  → 零交叉漏检，可能midpoint不准确

---

## 🎯 典型故障诊断流程

### 问题: 相位差只在0-2徘徊

#### 诊断步骤

**Step 1: 查看Zero-Cross Count**
```python
if count_delta == 0:
    print("❌ 零交叉检测完全失败")
    print("→ 继续Step 2")
else:
    print("✓ 零交叉检测工作")
    print("→ 继续Step 4")
```

**Step 2: 查看Min & Max**
```python
if min == max:
    print("❌ 无信号变化")
    print("→ 检查DA输出或ADC连接")
elif (max - min) < 100:
    print("⚠️ 信号太弱")
    print("→ 增大DA输出或改善耦合")
else:
    print("✓ 信号摆幅正常")
    print("→ 继续Step 3")
```

**Step 3: 查看Midpoint**
```python
center = (min + max) / 2
if abs(midpoint - center) > 100:
    print("❌ 动态零点校准失败")
    print("→ 可能V2算法问题")
elif abs(midpoint - 2048) > 500:
    print("⚠️ 信号严重偏置")
    print(f"→ DC偏置约 {(midpoint-2048)*0.00244:.2f}V")
    print("→ V2应该能处理，但检查硬件")
else:
    print("✓ 零点校准正常")
    print("→ 继续Step 4")
```

**Step 4: 分析Phase数据**
```python
if max(phases) - min(phases) < 5:
    print("❌ 相位数据异常（范围太小）")
    print("→ 可能phase_acc同步问题")
    print("→ 检查phase_acc_60m_sync2是否在0-65535循环")
else:
    print("✓ 相位检测正常工作")
```

---

## 📈 数据包发送策略

### 策略A: 固定速率发送（推荐用于诊断）
```
发送频率: 10 Hz (每100ms一个数据包)
数据率: 10 Hz × 12 bytes = 120 bytes/s
开销: 可忽略（相比4 MB/s ADC数据）

优点:
- ✅ 实时监控所有参数
- ✅ 数据量小，不影响ADC传输
- ✅ 可以看到参数随时间变化

缺点:
- ⚠️ 相位采样率低（10 Hz），看不到快速变化
```

**适用场景**: 
- 初始调试阶段
- 诊断相位检测问题
- 长期监控信号质量

---

### 策略B: 与相位数据交织（推荐用于正常运行）
```
格式: [Phase × 99] + [Full Packet × 1]
      └─99个纯相位数据 + 1个完整调试包

发送速率: 
- 相位: 4 MB/s × 99% = 3.96 MB/s (高采样率)
- 调试包: 4 MB/s × 1% = 40 KB/s

优点:
- ✅ 保持高相位采样率
- ✅ 定期获取调试信息
- ✅ 兼顾性能和可调试性

缺点:
- ⚠️ 解析稍复杂（需要识别帧头）
```

**适用场景**:
- 正常运行时持续监控
- 需要高速相位数据 + 周期性诊断

---

### 策略C: 按需切换（灵活但需要控制）
```
模式1: 纯相位模式（高速）
  - 连续发送phase_diff_8bit
  - 4 MB/s

模式2: 调试模式（诊断）
  - 连续发送完整数据包
  - 4 MB/s / 12 bytes = 333 kHz采样率

切换: 通过按键或UART命令
```

**优点**:
- ✅ 最灵活
- ✅ 按需选择性能或调试

**缺点**:
- ⚠️ 需要额外控制逻辑
- ⚠️ 不能同时获取高速相位和调试信息

---

## 💡 推荐方案

### 当前阶段（调试相位检测问题）

**推荐: 策略A（固定速率调试包）**

```verilog
// 修改adc_to_usb_60m.v
// 新增模式: test_mode = 3 (调试模式)

parameter DEBUG_PKT_INTERVAL = 24'd6_000_000; // 100ms @ 60MHz = 10Hz

// 数据包格式 (12 bytes):
// [0xAA, 0x55, phase_8bit, mid_high, mid_low, 
//  min_high, min_low, max_high, max_low,
//  count_high, count_low, checksum]
```

**实现要点**:
1. 在hs_adc_top_60m中添加调试信号输入（来自phase_detector_v2）
2. 在adc_to_usb_60m中添加数据包组装逻辑
3. 通过USB连续发送12字节数据包
4. PC端解析数据包，实时显示所有参数

**PC端显示示例**:
```
=== Phase Detector Debug Monitor ===
Time: 10.2s
Phase:        120° (stable ✓)
Midpoint:     2150 (bias: +102, 0.25V)
ADC Range:    1800 - 2300 (amplitude: 0.6V ✓)
Zero-Cross:   2,150,000 (freq: 215 kHz ✓)
Status:       All systems normal ✓
```

---

## 🎯 总结对比

| 信息类型 | 纯相位数据 | 完整调试包 |
|---------|-----------|-----------|
| **相位值** | ✅ 有 | ✅ 有 |
| **相位采样率** | ✅ 高 (4MHz) | ❌ 低 (333kHz) |
| **零交叉状态** | ❌ 无法知道 | ✅ 通过count判断 |
| **ADC信号质量** | ❌ 无法知道 | ✅ 通过min/max判断 |
| **DC偏置情况** | ❌ 无法知道 | ✅ 通过midpoint判断 |
| **故障诊断能力** | ❌ 弱 | ✅ 强 |
| **数据量** | ✅ 小 (1B) | ⚠️ 大 (12B) |
| **适用场景** | 正常运行 | 调试诊断 |

---

## 📝 结论

**当前问题（相位0-2）的最佳方案**:

1. **立即采用**: 策略A（固定速率调试包）
   - 发送频率: 10 Hz
   - 包含所有调试信息
   - 能快速定位问题根源

2. **问题解决后**: 切换到策略B（交织模式）或纯相位模式
   - 高速相位数据 + 周期性监控
   - 兼顾性能和可维护性

**预期效果**:
- 📊 可以看到midpoint是否偏离2048
- 📊 可以确认zero_cross_count是否增长
- 📊 可以判断ADC信号质量（min/max）
- 🎯 快速定位"相位0-2"问题的根本原因

你想实现哪种策略？我可以帮你修改代码！

